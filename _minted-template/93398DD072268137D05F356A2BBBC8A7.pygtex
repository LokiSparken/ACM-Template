\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{HLD}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{G}\PYG{p}{[}\PYG{n}{MAXN}\PYG{p}{];}
    \PYG{c+c1}{// 对i：sz以i为根子树大小，dep深度，par父亲，son重儿子，top所在链顶，id入栈序([题目编号]=树链编号)}
    \PYG{k+kt}{int} \PYG{n}{sz}\PYG{p}{[}\PYG{n}{MAXN}\PYG{p}{],}\PYG{n}{dep}\PYG{p}{[}\PYG{n}{MAXN}\PYG{p}{],}\PYG{n}{par}\PYG{p}{[}\PYG{n}{MAXN}\PYG{p}{],}\PYG{n}{son}\PYG{p}{[}\PYG{n}{MAXN}\PYG{p}{],}\PYG{n}{top}\PYG{p}{[}\PYG{n}{MAXN}\PYG{p}{],}\PYG{n}{id}\PYG{p}{[}\PYG{n}{MAXN}\PYG{p}{];}
    \PYG{c+cm}{/* 题目相关信息自己设，\PYGZsh{}\PYGZsh{}\PYGZsh{}注意输入编号、映射编号、数据结构编号间的映射和转换。\PYGZsh{}\PYGZsh{}\PYGZsh{} */}
    \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,}\PYG{n}{clk}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{init}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}=}\PYG{n}{n}\PYG{p}{;}\PYG{o}{++}\PYG{n}{i}\PYG{p}{)} \PYG{n}{G}\PYG{p}{[}\PYG{n}{i}\PYG{p}{].}\PYG{n}{clear}\PYG{p}{();}
        \PYG{n}{memset}\PYG{p}{(}\PYG{n}{son}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{son}\PYG{p}{));}\PYG{c+c1}{// 如果某结点没有儿子会被之前的数据影响}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{n}\PYG{o}{=}\PYG{n}{n}\PYG{p}{,}\PYG{n}{clk}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n+nf}{addedge}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{u}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{v}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{G}\PYG{p}{[}\PYG{n}{u}\PYG{p}{].}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{v}\PYG{p}{);}\PYG{n}{G}\PYG{p}{[}\PYG{n}{v}\PYG{p}{].}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{u}\PYG{p}{);} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n+nf}{getson}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{u}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{pre}\PYG{p}{)}\PYG{o}{//} \PYG{err}{标记深度、父亲、子树大小和重儿子，调用根}\PYG{n}{getson}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{);}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{dep}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{=}\PYG{n}{dep}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{par}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{=}\PYG{n}{pre}\PYG{p}{,}\PYG{n}{sz}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{fat}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{v}\PYG{p}{:}\PYG{n}{G}\PYG{p}{[}\PYG{n}{u}\PYG{p}{])}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{v}\PYG{o}{==}\PYG{n}{pre}\PYG{p}{)} \PYG{k}{continue}\PYG{p}{;}
            \PYG{n}{getson}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{u}\PYG{p}{);}
            \PYG{n}{sz}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{+=}\PYG{n}{sz}\PYG{p}{[}\PYG{n}{v}\PYG{p}{];}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{sz}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{fat}\PYG{p}{)} \PYG{n}{fat}\PYG{o}{=}\PYG{n}{sz}\PYG{p}{[}\PYG{n}{v}\PYG{p}{],}\PYG{n}{son}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n}{dfs}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{u}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{up}\PYG{p}{)}\PYG{c+c1}{// 标记链顶、入栈序，dfs(1,1);}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{top}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{=}\PYG{n}{up}\PYG{p}{,}\PYG{n}{id}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{=++}\PYG{n}{clk}\PYG{p}{,}\PYG{n}{reflect}\PYG{p}{[}\PYG{n}{clk}\PYG{p}{]}\PYG{o}{=}\PYG{n}{u}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{son}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{p}{;}\PYG{c+c1}{// 已经到达叶子}
        \PYG{n}{dfs}\PYG{p}{(}\PYG{n}{son}\PYG{p}{[}\PYG{n}{u}\PYG{p}{],}\PYG{n}{up}\PYG{p}{);}\PYG{c+c1}{// 每次先走重儿子，重儿子同样在该重链上，链顶相同}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{v}\PYG{p}{:}\PYG{n}{G}\PYG{p}{[}\PYG{n}{u}\PYG{p}{])}\PYG{c+c1}{// 其它轻儿子的链顶为其本身}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{v}\PYG{o}{!=}\PYG{n}{son}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{v}\PYG{o}{!=}\PYG{n}{par}\PYG{p}{[}\PYG{n}{u}\PYG{p}{])} \PYG{n}{dfs}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{v}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// 数据结构相关操作，一般线段树或树状数组（维护一段连续区间）}
    \PYG{c+c1}{// 注意：更新和查找操作要用对应的dfs序号id[pos]，可另外写个接口用于在外面调用，和DS分开}
    \PYG{c+c1}{// 接口里面二次调用一定要id[pos]啊啊啊啊啊啊啊啊猪！！！}

    \PYG{k+kt}{int} \PYG{n}{query}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{u}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{v}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{ans}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{top}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{!=}\PYG{n}{top}\PYG{p}{[}\PYG{n}{v}\PYG{p}{])}\PYG{c+c1}{// 先努力跳到同一根链上}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{dep}\PYG{p}{[}\PYG{n}{top}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]]}\PYG{o}{\PYGZlt{}}\PYG{n}{dep}\PYG{p}{[}\PYG{n}{top}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]])} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{);}\PYG{c+c1}{// 让链顶深的往上跳}
            \PYG{c+c1}{// 因为同一根链上是一段连续区间，所以可以直接调维护的数据结构的查询操作了}
            \PYG{n}{ans}\PYG{o}{=}\PYG{n}{max}\PYG{p}{(}\PYG{n}{ans}\PYG{p}{,}\PYG{n}{dsquery}\PYG{p}{(}\PYG{n}{id}\PYG{p}{[}\PYG{n}{top}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]],}\PYG{n}{id}\PYG{p}{[}\PYG{n}{u}\PYG{p}{],}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{));}\PYG{c+c1}{// 查要上跳的点所在链的信息}
            \PYG{n}{u}\PYG{o}{=}\PYG{n}{par}\PYG{p}{[}\PYG{n}{top}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]];}\PYG{c+c1}{// 然后跳出这条链，上跳到该链链顶的父亲}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// if(u==v) return ans;// 树状数组玄学RE时用}
        \PYG{c+c1}{// 此时u,v已经在同一条链上，又可以直接调用维护信息的数据结构的查询操作了qaq}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dep}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{dep}\PYG{p}{[}\PYG{n}{v}\PYG{p}{])} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{);}\PYG{c+c1}{// 记深度小的点为u（令其dfs入栈序小）}
        \PYG{c+c1}{//此时的u应该是原来u,v的LCA了，因此注意若边权下放点权要去掉LCA}
        \PYG{n}{ans}\PYG{o}{=}\PYG{n}{max}\PYG{p}{(}\PYG{n}{ans}\PYG{p}{,}\PYG{n}{dsquery}\PYG{p}{(}\PYG{n}{id}\PYG{p}{[}\PYG{n}{u}\PYG{p}{],}\PYG{n}{id}\PYG{p}{[}\PYG{n}{v}\PYG{p}{],}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{));}\PYG{c+c1}{// 即应变为dsqmax(id[son[u]],id[v])}
        \PYG{k}{return} \PYG{n}{ans}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{};}
\end{Verbatim}
