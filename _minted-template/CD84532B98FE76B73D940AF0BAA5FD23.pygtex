\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 可持久化权值线段树}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{maxn}\PYG{o}{=}\PYG{l+m+mf}{1e5}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{lson}\PYG{p}{[}\PYG{n}{maxn}\PYG{o}{*}\PYG{l+m+mi}{20}\PYG{p}{],}\PYG{n}{rson}\PYG{p}{[}\PYG{n}{maxn}\PYG{o}{*}\PYG{l+m+mi}{20}\PYG{p}{],}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{maxn}\PYG{o}{*}\PYG{l+m+mi}{20}\PYG{p}{];}
\PYG{c+c1}{// lson[i],rson[i]为结点i左右子树编号,sum维护的信息,本题中为所管辖数字区间内的数出现多少次}
\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{n}{maxn}\PYG{p}{],}\PYG{n}{rt}\PYG{p}{[}\PYG{n}{maxn}\PYG{p}{],}\PYG{n}{cnt}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,}\PYG{n}{m}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n+nf}{id}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)\PYGZob{}}\PYG{k}{return} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(),}\PYG{n}{temp}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(),}\PYG{n}{x}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{temp}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{()}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n+nf}{update}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{l}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{r}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{value}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{pre}\PYG{p}{,}\PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{cur}\PYG{p}{)}
\PYG{c+cm}{/**}
\PYG{c+cm}{ * 当前维护的区间l,r和要去更新的value，}
\PYG{c+cm}{ * 要移植的前置版本在该处的编号pre，现正创的新版本的当前结点编号cur（更新时给它打编号所以引用）}
\PYG{c+cm}{**/}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// 复制前置版本的信息}
    \PYG{o}{++}\PYG{n}{cnt}\PYG{p}{;}
    \PYG{n}{lson}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{o}{=}\PYG{n}{lson}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{],}\PYG{n}{rson}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rson}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{],}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{o}{=}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{];}
    \PYG{c+c1}{// 因为要从这条分岔下去更新，所以这里的信息要变化}
    \PYG{o}{++}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{];}
    \PYG{c+c1}{// 记录这个新结点的编号}
    \PYG{n}{cur}\PYG{o}{=}\PYG{n}{cnt}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{l}\PYG{o}{==}\PYG{n}{r}\PYG{p}{)} \PYG{k}{return} \PYG{p}{;}\PYG{c+c1}{// 到底，更新完毕}
    \PYG{k+kt}{int} \PYG{n}{mid}\PYG{o}{=}\PYG{p}{(}\PYG{n}{l}\PYG{o}{+}\PYG{n}{r}\PYG{p}{)}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{c+c1}{// 否则继续向下}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{value}\PYG{o}{\PYGZlt{}=}\PYG{n}{mid}\PYG{p}{)} \PYG{n}{update}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{mid}\PYG{p}{,}\PYG{n}{value}\PYG{p}{,}\PYG{n}{lson}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{],}\PYG{n}{lson}\PYG{p}{[}\PYG{n}{cur}\PYG{p}{]);}
    \PYG{k}{else} \PYG{n}{update}\PYG{p}{(}\PYG{n}{mid}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{value}\PYG{p}{,}\PYG{n}{rson}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{],}\PYG{n}{rson}\PYG{p}{[}\PYG{n}{cur}\PYG{p}{]);}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{n+nf}{query}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{l}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{r}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{pre}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{last}\PYG{p}{)}
\PYG{c+cm}{/**}
\PYG{c+cm}{ * 当前查询的区间范围l,r和要查的第k大}
\PYG{c+cm}{ * 查询的版本左右两端编号}
\PYG{c+cm}{**/}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{l}\PYG{o}{==}\PYG{n}{r}\PYG{p}{)} \PYG{k}{return} \PYG{n}{l}\PYG{p}{;}\PYG{c+c1}{// 到底，找到所查第k大的值（离散化后）}
    \PYG{k+kt}{int} \PYG{n}{mid}\PYG{o}{=}\PYG{p}{(}\PYG{n}{l}\PYG{o}{+}\PYG{n}{r}\PYG{p}{)}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{c+c1}{// 否则看右端版本小的一半数有多少个,减去左端版本的个数,即查询版本内小的那一半数有多少个}
    \PYG{k+kt}{int} \PYG{n}{s}\PYG{o}{=}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{lson}\PYG{p}{[}\PYG{n}{last}\PYG{p}{]]}\PYG{o}{\PYGZhy{}}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{lson}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{]];}
    \PYG{c+c1}{// 如果个数比k大，说明第k大个在小的那半数里，也就是左子树中}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZgt{}=}\PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n}{query}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{mid}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{lson}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{],}\PYG{n}{lson}\PYG{p}{[}\PYG{n}{last}\PYG{p}{]);}
    \PYG{k}{else} \PYG{k}{return} \PYG{n}{query}\PYG{p}{(}\PYG{n}{mid}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{s}\PYG{p}{,}\PYG{n}{rson}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{],}\PYG{n}{rson}\PYG{p}{[}\PYG{n}{last}\PYG{p}{]);}
    \PYG{c+c1}{// 个数比k小，转化为在大的那半数里求第k\PYGZhy{}sum大的数}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
