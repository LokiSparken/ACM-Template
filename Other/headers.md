## 浮点
1. 浮点初始化memset(d,0x7f,sizeof(d));
2. 浮点数比大小:
  * 相等 if ( fabs (a-b) <= eps )
  * 大于 if ( a>b && fabs (a-b) > eps )
  * 小于 if ( a<b && fabs (a-b) > eps )

## 整数类型范围
1. 255：IP位址是一个32位的二进制数，在IPv4中被等分为4段。每一段所支持的最大值"11111111"在十进制中即为255。而默认的子网掩码为255.255.255.0 。
2. 65535：2^16-1。早期许多程序的数据采用16bit无符号整数（C/C++:uint16_t）。有时发生计算错误，得到本来不该有的-1（下溢出），而-1在16bit无符号整数中就会变成这个值。
3. 2147483647：2^31-1。32bit带符号整数（C/C++:int32_t）的最大值。
4. 4294967296：2^32。有时4294967295=2^32-1会作为32bit无符号整数（C/C++:uint32_t）的最大值，出现在类似65535的计算错误场合。
5. 92233720368547758072：2^63-1。64bit带符号整数（C/C++:int64_t）的最大值。可是由于这个数太大，很少被留意

## 热身赛
1. 测pb_ds
2. python3计算器
3. 

## 计算器
1. 终端
  * 分解素因数factor num  
  * 逆串rev+enter string
2. python3
  * from fractions import *(Fraction, gcd)
    * 最简分数fraction(a,b)        
    * gcd(a,b)
  * from math import *
    * 阶乘factorial(num)

## Attention
1. 审题
  * **读新题的优先级高于一切**
  * **注意限制条件**，不清楚的善用Clarification
  * 读完题、交题前都要注意clarification
  * 每题至少两人确认题意
2. 打印
  * 交完题目马上打印并让机
  * 打表时想清楚打哪些量，代码乱改前注意备份。善用打印，保留代码。
3. 做题
  * 
4. 构造不要开场做
5. 
6. 上机前和队友确认做法
7. 有猜想性质的后面写
8. 想不出优雅复杂度但过了很多队的<br>莽暴力</br>
9. 若有多道要写，先写容易码的，码量小的，想得无敌清楚的题
10. 细节、公式等上机前在纸上写好，不要在机子前越写越乱
11. claris: 交题前检查solve(n,m)==solve(m,n)?
12. 检查是否所有东西都已经清空
中后期题考虑一人写一人辅助，及时发现手误
最后半小时不要慌
取模的输出前再模一次
舍入输出若abs不超过eps，需要强行设置0防止-0.000000的出现
可能有spj的题目提交前也应尽量与样例完全一致
写了半小时以上的考虑是否弃题



## Debug
1. 初始化，清空图，0和n等边界，mem里面sizeof(int)还是ll
2. for里是给本层循环变量++咩？
3. 区间l,r为防坑：if(l>r) swap(l,r);
4. 考虑小数据有没有发生突变的地方
5. 注意板子有没有哪里要改ll
6. inf的大小符不符合
7. 

## 打表找规律


## 优化
1. 数论
  * 分块加速O(sqrt(n))
  * 枚举除数、调和级数O(log(n))
  * floor函数求和、ceil函数求和(hdu6134)
  * get_pre里的取模，以及连续取模注意顺序，还有爆精度取模和式子i从2开始(n/i)
  * **WA太久或出不了，考虑公式是否错误**
2. cdq分治
3. 树上点分治
4. 一般分块